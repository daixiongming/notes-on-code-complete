# 第3章 三思而后行：前期准备
不同规模的构建，需要不同程度的准备工作，项目的成败，早已埋下伏笔。构建一般占项目时间的65%，而糟糕的准备工作会让构建时间增加两三倍。
## 3.1 前期准备的重要性
高质量的软件来自高质量的实践，如何保证质量？
* 前期：关注需求、设计。
* 中期：关注构建。
* 后期：关注测试。

本书重点关注中期，但是在开始构建之前，需要弄清前期准备做到了什么程度，贸然开场容易悲剧。
### 现代软件开发是否需要前期准备？
需要。前期准备可以降低风险，不同的项目可能需要不同的前期准备实践，但不能没有。

### 不完整的前期准备的理由
* 开发者没有经验——那就去学啊。
* 按捺不住写代码的心——多碰几次壁。
* 上级让你赶紧写代码！——拒绝上级；假装在编程；教育上级；跳槽。

### 构建之前做好前期准备的理由
你可以拿它来教育别人。

#### 诉诸逻辑
* 需要弄清楚到底想构建个啥。
* 需要弄清楚怎么去构建系统。

#### 诉诸类比
* 造房子
* 软件开发食物链：程序员在食物链尽头。

#### 诉诸数据
* 最后阶段更改的代价是10~100倍。

#### 老板敏捷测试
自我实现预言：
* 我们必须立即开始编码因为还有很多调试工作要做。
* 我们没有计划多少时间去测试因为不会找到太多的缺陷。
* 我们充分研究了需求和设计，在编码和调试的时候不会遇到大的问题。

## 3.2 确定你开发的软件类型
针对不同的软件类型，需要不同的生命周期模型:
* 商业系统
* 关键任务系统
* 嵌入式性命攸关系统

### 迭代方法在前期准备中的作用
* 先做80%的需求分析，则类似串行
* 先做20%的需求分析，则类似迭代

### 在迭代方法与串行方法间的选择
* 需求是否明确？
* 设计是否复杂？
* 团队对领域是否熟悉？
* 项目风险大不大？
* 更改需求、设计的代价如何？

## 3.3 问题定义
* 好的问题定义弄清楚问题是什么，而不要考虑实现。
* 问题定义在需求分析之前，使用用户语言描述。
* 最好的解决方案可能不需要写软件。
* 除非是为了解决计算机系统问题，否则不使用计算机语言。
* 问题定义出错的代价：浪费了时间，没有解决真正的问题。

## 3.4 需求分析
需求分析讨论软件怎么解决问题，是解决方案的第一步。
### 为什么需要正式的需求？
* 确保用户而非程序员决定系统功能，程序员明确知道用户需要什么。
* 避免争吵，以需求为准。
* 好的需求会减少开始构建后的变更。

### 稳定需求的神话
稳定的需求是软件开发的圣杯。
* 用户往往不能准备描述需求。
* 只有充分使用系统，才能深入理解系统。
* 开发过程会使用户更好的理解系统，这也是需求变更的主要来源。
* 典型的系统会有25%的需求变更，花费70%~85时间重做。

### 在构建时应对需求变化
* 检查需求分析的质量，如有问题，尽早返工。
* 确保每个人明白需求变更的代价，正确应对“特性中毒者”。
* 建立变更控制过程，做到程序员顾客都满意。
* 使用能适应需求变更的开发方法：原型进化、渐进交付、小开发周期。
* 放弃项目。
* 始终关注项目的商业价值。

## 3.5 架构设计
架构设计，一般对应“概要设计文档”，架构决定了系统的“概念完整”。架构设计进行工作分解，直至程序员可以上手工作。
### 典型的架构要素
#### 程序组织结构
* 系统鸟瞰。
* 考虑了备选方案，综合考虑使用目前的方案。
* 设计主要模块，追溯相应的需求。
* 模块职责分明，对其它模块依赖越少越好。
* 模块间的通信方式有良好定义，明确调用关系。

#### 主要的类
* 描述主要的类，职责以及和其他类的关系，继承体系、状态转换图、对象持久化方法，如何组织成子系统。
* 考虑备选方案，以及使用本方案的理由，不必要描述所有的类。

#### 数据设计
* 文件、表格设计，数据结构选择的理由。
* 数据通常只由一个类或子系统获取。
* 数据库使用的高层组织和内容，选择数据库还是平面文件，单数据库还是多数据库。

#### 用户接口设计
* 需求阶段设计亦可。
* 用户界面可替代原则。
* 命令行用户接口在测试中很有用。

#### 资源管理
* 关键资源如：数据库连接、进程、句柄。
* 内存管理：一般情况和极端情况。
* 由开发环境管理还是自行管理。

#### 安全
* 设计级别的安全与代码级别的安全。
* 建立威胁模型。
* 编程规范要考虑缓存、输入数据过滤、加密、错误信息的详细程度、内存关键数据的保护等。

#### 性能
* 如果关心性能，则需求中要明确。权衡速度、内存、花销。
* 架构要说明为何能达到性能目标，阐明风险，说明是否需要特殊的算法，权衡时间和空间。

#### 扩展性
架构如何应对用户数、服务数、网络节点数、数据库记录的增加。

#### 互操作性
如何为其他软硬件提供数据或资源。

#### 国际化/本地化
i18n问题，如何存储使用字符串。

#### 输入输出
* 描述前向、后向、即时的输入输出。
* 在什么层面检测错误：字段、记录、数据流、文件。

#### 错误处理
90%的代码在处理异常情况。
* 检错还是纠错，忽略还是终止，是否通知用户。
* 主动检测还是被动检测。
* 错误如何传播？策略要一致，不使用户费解。
* 异常如何处理, 捕捉、记录、存档。
* 在什么层面处理错误。
* 每个类输入数据如何验证，分散还是集中，输入是否干净。
* 使用开发环境的错误处理系统还是自定义错误系统。

#### 容错
* 重试与回退。
* 用备用方法。
* 用选举法。
* 用假值替代。

总体策略：退化、转入特定状态、关闭或重启。

#### 可行性
如可能有不可行处，要充分说明，考虑原型概念验证或研究。

#### 过度设计
通过过度设计提高鲁棒性，应对缺陷的乘法原理。

#### 买或是开发
弄清为什么要自己开发。

#### 重用决策
重用是如何满足需求的。

#### 变更策略
* 可能的变更已纳入考虑，最可能的变更易于实现，单一变更影响的类较少。
* 一些方法：版本号、保留字段、设计文件、代码生成器。
* 延迟决策：使用表驱动代替硬编码的条件判断、使用配置文件。

### 架构质量
* 好的架构指出类之后的隐含信息，包含或不包含某些设计的理由。
* 好的架构是自然的，一个优美的概念结合一些自组织的附属概念。
* 架构更改时应当与整体概念保持一致。
* 架构应当阐明目标，比如功能相同的软件性能要求可能不同。
* 架构应当阐明主要决策的理由。
* 好的架构应当尽量独立于机器及语言。
* 架构应当阐明风险及解决方法。
* 架构应当包含多种视角。
* 你应当能理解架构的全部内容。

## 3.6 前期准备需要的时间
取决于软件类型：
* 需求不确定的正式项目：可能需要时间和分析师一起把需求理清。
* 需求不确定的非正式项目：自己理清需求，直到需求的易变部分对构建的影响最小。

只要需求不明确，需求本身就要作为一个项目来做，只有明确了需求，才能估计开发的时间。
